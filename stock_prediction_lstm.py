# -*- coding: utf-8 -*-
"""Stock_Prediction_LSTM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10jUqE8_fYqaNwOyq-tSRtJX9Tlsy1No6

# **Stock Price Prediction**

# LSTM
"""

#Importing the libraries

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import math

from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM

def dataset_transform(dataset):
  data = []
  for i in range(len(dataset)):
    a = dataset[i][0]
    data.append(float(a))
  return np.array([data])

def createDataset(dataset, time_step = 1):
  datax, datay = [], []
  for i in range(len(dataset) - time_step - 1):
    a = dataset[i:(i + time_step), 0]
    datax.append(a)
    datay.append(dataset[i + time_step, 0])
  return np.array(datax), np.array(datay)

from google.colab import files
uploaded = files.upload()

#Importing the data set

import io
data_set = pd.read_csv(io.BytesIO(uploaded['Google_Stock_Price_Custom.csv']))
training_set = data_set[0:int(len(data_set)*0.8)]
testing_set = data_set[int(len(data_set)*0.8):]
data_set

training_set

testing_set

train_set_org = training_set.iloc[:,1:2].values
test_set_org = testing_set.iloc[:,1:2].values
print(train_set_org, test_set_org)

#Feature Scaling using Normalization

xscaler = MinMaxScaler()
yscaler = MinMaxScaler()
train_set = xscaler.fit_transform(train_set_org)
test_set = yscaler.fit_transform(test_set_org)
print(train_set[:5], test_set[:5])

#Getting the inputs

time_steps = 100
x_train, y_train = createDataset(train_set,time_steps)
x_test, y_test = createDataset(test_set,time_steps)      
x_train.shape

#Reshaping the data 
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1)) # batch size, time steps, features 
print(x_train.shape)
print(y_train.shape)

#Initializing the RNN
regressor = Sequential()

#Adding the input layer and LSTM layer
regressor.add(LSTM(units = 10, activation = 'sigmoid', input_shape = (time_steps, 1))) 
'''
  - Sigmoid functions gives better results than tanh fucntion 

'''

#Adding the output layer
regressor.add(Dense(units = 1)) 
'''
  - As we expect output n+1th day stock price, there will be only 1 Neuron so units = 1

'''

#Compiling the RNN

regressor.compile(optimizer = 'adam', loss = 'mean_squared_error')

#Fitting the RNN

regressor.fit(x_train, y_train, batch_size = 32, epochs = 200)

#Predicting the stock price

inputs = x_test
inputs = np.reshape(inputs, (inputs.shape[0],inputs.shape[1],1))
predicted_stock_price = regressor.predict(inputs)
predicted_stock_price = yscaler.inverse_transform(predicted_stock_price)
y_test = yscaler.inverse_transform(y_test.reshape(-1,1))
print(predicted_stock_price[:5], y_test[:5])

math.sqrt(mean_squared_error(y_test,predicted_stock_price))

#Visualizing the results

plt.plot(y_test, color = 'red', label = "Actual price")
plt.plot(predicted_stock_price, color = "blue", label = "Predicted price")
plt.title("Stock Price Prediction")
plt.xlabel("Days")
plt.ylabel("Stock price")
plt.legend()
plt.show()

real_stock_price = training_set.iloc[:,1:2].values
real_stock_price[:5]

predicted_stock_price_train = regressor.predict(x_train)
predicted_stock_price_train = xscaler.inverse_transform(predicted_stock_price_train)
predicted_stock_price_train[:5]

#Visualizing the results
plt.figure(figsize = (20,5))
plt.plot(real_stock_price[time_steps+1:], color = 'red', label = "Acutal price")
plt.plot(predicted_stock_price_train, color = "blue", label = "Predicted price")
plt.title("Stock Price Prediction")
plt.xlabel("Days")
plt.ylabel("Stock price")
plt.legend()
plt.show()

from google.colab import files
uploaded = files.upload()

import io
latest_dataset1 = pd.read_csv(io.BytesIO(uploaded['Google_Stock_Validate.csv']))
latest_dataset1

realprice = latest_dataset1[time_steps:time_steps+1].iloc[:,1:2].values
realprice

latest_dataset = latest_dataset1[:time_steps]
latest_dataset

transformed_ds = latest_dataset.iloc[:,1:2].values
print(transformed_ds)
valid_xtrain = dataset_transform(transformed_ds)
testscaler = MinMaxScaler()

may2020 = testscaler.fit_transform(valid_xtrain)
may2020.shape

may2020 = np.reshape(may2020, (may2020.shape[0],may2020.shape[1],1))

predicted_price_input = regressor.predict(may2020)
predict_ds = np.zeros(shape=(len(predicted_price_input), time_steps) )
predict_ds[:,0] = predicted_price_input[:,0]
predicted_price_input = testscaler.inverse_transform(predict_ds)[:,0]
realprice = np.reshape(realprice, (1))

print("Predicted Price : ",predicted_price_input[0],"\nReal Stock Price: ", realprice[0])

"""# Moving Average"""

def moving_average(dataset, timestep):
  datax, datay = [], []
  for i in range(len(dataset) - timestep - 1):
    avg = dataset[i:(timestep + i), 0].sum() / timestep
    datax.append([avg])
    datay.append(dataset[i + timestep + 1])
  return np.array(datax), np.array(datay)

train_set_avg = data_set.iloc[:,1:2].values
x_train_avg, y_train_avg = moving_average(train_set_avg, 30)

math.sqrt(mean_squared_error(x_train_avg,y_train_avg))

#Visualizing the results
plt.figure(figsize = (20,5))
plt.plot(y_train_avg, color = 'blue', label = "Actual price")
plt.plot(x_train_avg, color = "red", label = "Predicted price")
plt.title("Stock Price Prediction using MOVING AVERAGE")
plt.xlabel("Days")
plt.ylabel("Stock price")
plt.legend()
plt.show()